/*
 * File:     prog1.c
 *
 * Purpose:  Use tree-structured communication to find the global sum
 *           of a random collection of ints
 *
 * Compile:  mpicc -g -Wall -o prog1 prog1.c
 * Run:      mpiexec -n <comm_sz> ./prog1
 *
 * Input:    None
 * Output:   Random values generated by processes, and their global sum.
 *
 * Note:     This version assumes comm_sz is a power of 2.
 *
 * 
 *
 * 
 */
#include <stdio.h>
#include <stdlib.h>
#include <mpi.h>
#include "timer.h"

int Global_sum(int my_int, int my_rank, int comm_sz, MPI_Comm comm); 

const int MAX_CONTRIB = 20;

int main(void) {
   int i, sum, my_int;
   int my_rank, comm_sz;
   MPI_Comm comm;
   int* all_ints = NULL;
   double start, finish, elapsed;
   
   MPI_Init(NULL, NULL);
   comm = MPI_COMM_WORLD;
   MPI_Comm_size(comm, &comm_sz);
   MPI_Comm_rank(comm, &my_rank);

   /*
   Add Code Here.   //Generate a random collection of ints: my_int
   */
   my_int = my_rank;
   GET_TIME(start);
   sum = Global_sum(my_int, my_rank, comm_sz, comm);
   GET_TIME(finish);
   elapsed = finish - start;

   if ( my_rank == 0) {
      all_ints = malloc(comm_sz*sizeof(int));
      
      MPI_Gather(&my_int, 1, MPI_INT, all_ints, 1, MPI_INT, 0, comm);
      
      printf("Ints being summed:\n   ");
      for (i = 0; i < comm_sz; i++)
         printf("%d ", all_ints[i]);
      printf("\n");
      printf("Sum = %d\n",sum);
      printf("Calculating global time spend: %.15e seconds\n", elapsed);
      free(all_ints);
   } else {
      MPI_Gather(&my_int, 1, MPI_INT, all_ints, 1, MPI_INT, 0, comm);
   }
   
   MPI_Finalize();
   return 0;
}  /* main */

/*-------------------------------------------------------------------
 * Function:   Global_sum
 * Purpose:    Implement a global sum using tree-structured communication
 * Notes:       
 * 1.  comm_sz must be a power of 2
 * 2.  The return value is only valid on process 0
 */
int Global_sum(
      int my_int    /* in */,
      int my_rank   /* in */,
      int comm_sz   /* in */,
      MPI_Comm comm /* in */) {
   int comm_sz_now = comm_sz;
   int local_int, local_int_recv, my_sum;
   local_int = my_int;
   while (comm_sz_now > 1){
      if (my_rank < comm_sz_now/2){
         MPI_Recv(&local_int_recv, 1, MPI_INT, my_rank + comm_sz_now/2, my_rank + comm_sz_now/2, comm, MPI_STATUS_IGNORE);
         local_int = local_int + local_int_recv;
      } else if (my_rank < comm_sz_now) {
         MPI_Send(&local_int, 1, MPI_INT, my_rank - comm_sz_now/2, my_rank, comm);
      }
      comm_sz_now = comm_sz_now /2;
   }
   my_sum = local_int;
   return my_sum;
}  /* Global_sum */
